// Generated by TinyPG v1.2 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace SimpleExpressionEvaluator.Parser
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseBooleanExpr(node); // NonTerminal Rule: BooleanExpr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
            if (tok.Type != TokenType.EOF)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void ParseConditional(ParseNode parent) // NonTerminalSymbol: Conditional
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Conditional), "Conditional");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IF); // Terminal Rule: IF
            if (tok.Type != TokenType.IF)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BROPEN); // Option Rule
            if (tok.Type == TokenType.BROPEN)
            {
                tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
                if (tok.Type != TokenType.BROPEN)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
            }

             // Concat Rule
            ParseBooleanExpr(node); // NonTerminal Rule: BooleanExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRCLOSE); // Option Rule
            if (tok.Type == TokenType.BRCLOSE)
            {
                tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
                if (tok.Type != TokenType.BRCLOSE)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.THEN); // Terminal Rule: THEN
            if (tok.Type != TokenType.THEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.THEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

             // Concat Rule
            ParseBooleanExpr(node); // NonTerminal Rule: BooleanExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.ELSE); // Option Rule
            if (tok.Type == TokenType.ELSE)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.ELSE); // Terminal Rule: ELSE
                if (tok.Type != TokenType.ELSE)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ELSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseBooleanExpr(node); // NonTerminal Rule: BooleanExpr
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Conditional

        private void ParseIdentifier(ParseNode parent) // NonTerminalSymbol: Identifier
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Identifier), "Identifier");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.ARRAYNAME, TokenType.METHODNAME); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                    if (tok.Type != TokenType.IDENTIFIER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.ARRAYNAME:
                    ParseArray(node); // NonTerminal Rule: Array
                    break;
                case TokenType.METHODNAME:
                    ParseMethod(node); // NonTerminal Rule: Method
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Identifier

        private void ParseBooleanExpr(ParseNode parent) // NonTerminalSymbol: BooleanExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BooleanExpr), "BooleanExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseCompareExpr(node); // NonTerminal Rule: CompareExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BOOLEAN); // ZeroOrMore Rule
            while (tok.Type == TokenType.BOOLEAN)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.BOOLEAN); // Terminal Rule: BOOLEAN
                if (tok.Type != TokenType.BOOLEAN)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BOOLEAN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseCompareExpr(node); // NonTerminal Rule: CompareExpr
            tok = scanner.LookAhead(TokenType.BOOLEAN); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: BooleanExpr

        private void ParseCompareExpr(ParseNode parent) // NonTerminalSymbol: CompareExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CompareExpr), "CompareExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseAddExpr(node); // NonTerminal Rule: AddExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMPARE); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMPARE)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMPARE); // Terminal Rule: COMPARE
                if (tok.Type != TokenType.COMPARE)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPARE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseAddExpr(node); // NonTerminal Rule: AddExpr
            tok = scanner.LookAhead(TokenType.COMPARE); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CompareExpr

        private void ParseAddExpr(ParseNode parent) // NonTerminalSymbol: AddExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddExpr), "AddExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseMultExpr(node); // NonTerminal Rule: MultExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.PLUSMINUS); // ZeroOrMore Rule
            while (tok.Type == TokenType.PLUSMINUS)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.PLUSMINUS); // Terminal Rule: PLUSMINUS
                if (tok.Type != TokenType.PLUSMINUS)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseMultExpr(node); // NonTerminal Rule: MultExpr
            tok = scanner.LookAhead(TokenType.PLUSMINUS); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AddExpr

        private void ParseMultExpr(ParseNode parent) // NonTerminalSymbol: MultExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultExpr), "MultExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParsePowerExpr(node); // NonTerminal Rule: PowerExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.MULTDIV); // ZeroOrMore Rule
            while (tok.Type == TokenType.MULTDIV)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.MULTDIV); // Terminal Rule: MULTDIV
                if (tok.Type != TokenType.MULTDIV)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTDIV.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParsePowerExpr(node); // NonTerminal Rule: PowerExpr
            tok = scanner.LookAhead(TokenType.MULTDIV); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: MultExpr

        private void ParsePowerExpr(ParseNode parent) // NonTerminalSymbol: PowerExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PowerExpr), "PowerExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseAtom(node); // NonTerminal Rule: Atom

             // Concat Rule
            tok = scanner.LookAhead(TokenType.POWER); // ZeroOrMore Rule
            while (tok.Type == TokenType.POWER)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.POWER); // Terminal Rule: POWER
                if (tok.Type != TokenType.POWER)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POWER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseAtom(node); // NonTerminal Rule: Atom
            tok = scanner.LookAhead(TokenType.POWER); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: PowerExpr

        private void ParseParams(ParseNode parent) // NonTerminalSymbol: Params
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Params), "Params");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.TRUE, TokenType.FALSE, TokenType.NULL, TokenType.INTEGER, TokenType.NUMBER, TokenType.STRING, TokenType.BROPEN, TokenType.IDENTIFIER, TokenType.ARRAYNAME, TokenType.METHODNAME, TokenType.IF, TokenType.UNARY); // Option Rule
            if (tok.Type == TokenType.TRUE
                || tok.Type == TokenType.FALSE
                || tok.Type == TokenType.NULL
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.BROPEN
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.ARRAYNAME
                || tok.Type == TokenType.METHODNAME
                || tok.Type == TokenType.IF
                || tok.Type == TokenType.UNARY)
            {
                ParseBooleanExpr(node); // NonTerminal Rule: BooleanExpr
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                if (tok.Type != TokenType.COMMA)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseBooleanExpr(node); // NonTerminal Rule: BooleanExpr
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Params

        private void ParseMethod(ParseNode parent) // NonTerminalSymbol: Method
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Method), "Method");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.METHODNAME); // Terminal Rule: METHODNAME
            if (tok.Type != TokenType.METHODNAME)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.METHODNAME.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

             // Concat Rule
            tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
            if (tok.Type != TokenType.BROPEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

             // Concat Rule
            tok = scanner.LookAhead(TokenType.TRUE, TokenType.FALSE, TokenType.NULL, TokenType.INTEGER, TokenType.NUMBER, TokenType.STRING, TokenType.BROPEN, TokenType.IDENTIFIER, TokenType.ARRAYNAME, TokenType.METHODNAME, TokenType.IF, TokenType.UNARY, TokenType.COMMA); // Option Rule
            if (tok.Type == TokenType.TRUE
                || tok.Type == TokenType.FALSE
                || tok.Type == TokenType.NULL
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.BROPEN
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.ARRAYNAME
                || tok.Type == TokenType.METHODNAME
                || tok.Type == TokenType.IF
                || tok.Type == TokenType.UNARY
                || tok.Type == TokenType.COMMA)
            {
                ParseParams(node); // NonTerminal Rule: Params
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
            if (tok.Type != TokenType.BRCLOSE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Method

        private void ParseArray(ParseNode parent) // NonTerminalSymbol: Array
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Array), "Array");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ARRAYNAME); // Terminal Rule: ARRAYNAME
            if (tok.Type != TokenType.ARRAYNAME)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARRAYNAME.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

             // Concat Rule
            tok = scanner.Scan(TokenType.SBOPEN); // Terminal Rule: SBOPEN
            if (tok.Type != TokenType.SBOPEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SBOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

             // Concat Rule
            ParseBooleanExpr(node); // NonTerminal Rule: BooleanExpr

             // Concat Rule
            tok = scanner.Scan(TokenType.SBCLOSE); // Terminal Rule: SBCLOSE
            if (tok.Type != TokenType.SBCLOSE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SBCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Array

        private void ParseQualifiedName(ParseNode parent) // NonTerminalSymbol: QualifiedName
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.QualifiedName), "QualifiedName");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseIdentifier(node); // NonTerminal Rule: Identifier

             // Concat Rule
            tok = scanner.LookAhead(TokenType.DOT); // ZeroOrMore Rule
            while (tok.Type == TokenType.DOT)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.DOT); // Terminal Rule: DOT
                if (tok.Type != TokenType.DOT)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseIdentifier(node); // NonTerminal Rule: Identifier
            tok = scanner.LookAhead(TokenType.DOT); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: QualifiedName

        private void ParseUnaryExpr(ParseNode parent) // NonTerminalSymbol: UnaryExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.UnaryExpr), "UnaryExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.UNARY); // Terminal Rule: UNARY
            if (tok.Type != TokenType.UNARY)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNARY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

             // Concat Rule
            ParseAtom(node); // NonTerminal Rule: Atom

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: UnaryExpr

        private void ParseAtom(ParseNode parent) // NonTerminalSymbol: Atom
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Atom), "Atom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.TRUE, TokenType.FALSE, TokenType.NULL, TokenType.INTEGER, TokenType.NUMBER, TokenType.STRING, TokenType.BROPEN, TokenType.IDENTIFIER, TokenType.ARRAYNAME, TokenType.METHODNAME, TokenType.IF, TokenType.UNARY); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.TRUE:
                    tok = scanner.Scan(TokenType.TRUE); // Terminal Rule: TRUE
                    if (tok.Type != TokenType.TRUE)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TRUE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.FALSE:
                    tok = scanner.Scan(TokenType.FALSE); // Terminal Rule: FALSE
                    if (tok.Type != TokenType.FALSE)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FALSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.NULL:
                    tok = scanner.Scan(TokenType.NULL); // Terminal Rule: NULL
                    if (tok.Type != TokenType.NULL)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NULL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                    if (tok.Type != TokenType.INTEGER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.NUMBER:
                    tok = scanner.Scan(TokenType.NUMBER); // Terminal Rule: NUMBER
                    if (tok.Type != TokenType.NUMBER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                    if (tok.Type != TokenType.STRING)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.BROPEN:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
                    if (tok.Type != TokenType.BROPEN)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);

                     // Concat Rule
                    ParseBooleanExpr(node); // NonTerminal Rule: BooleanExpr

                     // Concat Rule
                    tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
                    if (tok.Type != TokenType.BRCLOSE)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.IDENTIFIER:
                case TokenType.ARRAYNAME:
                case TokenType.METHODNAME:
                    ParseQualifiedName(node); // NonTerminal Rule: QualifiedName
                    break;
                case TokenType.IF:
                    ParseConditional(node); // NonTerminal Rule: Conditional
                    break;
                case TokenType.UNARY:
                    ParseUnaryExpr(node); // NonTerminal Rule: UnaryExpr
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Atom


    }

    #endregion Parser
}
